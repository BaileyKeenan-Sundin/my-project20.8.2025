// server/index.js
import express from "express";
import cors from "cors";
import fetch from "node-fetch";
import * as dotenv from "dotenv";
import http from "http";
import { Server as SocketIOServer } from "socket.io";
import path from "path";
import { fileURLToPath } from "url";

import {
  findEvents,
  getEventById,
  invalidateEventsCache,
} from "./lib/events.js";

// ──────────────────────────────────────────────────────────────
// Env setup
// ──────────────────────────────────────────────────────────────
const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.join(__dirname, ".env") });

const app = express();
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || "0.0.0.0";
const CORS_ORIGIN = process.env.CORS_ORIGIN || "http://localhost:5173";
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET || "devsecret123";
const WP = (process.env.WP_BASE_URL || "").replace(/\/$/, "");

// ──────────────────────────────────────────────────────────────
// HTTP server + Socket.IO
// ──────────────────────────────────────────────────────────────
const httpServer = http.createServer(app);
const io = new SocketIOServer(httpServer, {
  path: "/socket.io",
  cors: { origin: CORS_ORIGIN },
});

io.on("connection", (socket) => {
  console.log("[socket] connected:", socket.id);
  socket.on("disconnect", (reason) => {
    console.log("[socket] disconnected:", socket.id, reason);
  });
});

// ──────────────────────────────────────────────────────────────
// Middleware
// ──────────────────────────────────────────────────────────────
app.use(cors({ origin: CORS_ORIGIN }));
app.use(express.json({ limit: "1mb" }));

// ──────────────────────────────────────────────────────────────
// Small helpers
// ──────────────────────────────────────────────────────────────
async function fetchJSON(u, init) {
  const r = await fetch(u, init);
  if (!r.ok) throw new Error(`HTTP ${r.status} for ${u}`);
  return r.json();
}
function verifyWebhook(req) {
  const hdr = req.get("X-Webhook-Secret") || "";
  return WEBHOOK_SECRET && hdr === WEBHOOK_SECRET;
}
const recent = new Map();
function shouldDrop(key, windowMs = 2000) {
  const now = Date.now();
  const last = recent.get(key);
  recent.set(key, now);
  if (recent.size > 500) {
    for (const [k, t] of recent) if (now - t > windowMs * 2) recent.delete(k);
  }
  return last && now - last < windowMs;
}

// Presentation-only date shortener (does not change stored data)
function dateShort(s) {
  const m = String(s || "").match(/^(\d{4}-\d{2}-\d{2})/);
  return m ? m[1] : (s || "Not specified");
}

// Tiny in-memory cache for page enrichment (non-persistent)
const ENRICH_TTL_MS = Number(process.env.ENRICH_TTL_MS || 300000); // 5 min
const enrichCache = new Map();
function cacheGet(url) {
  const e = enrichCache.get(url);
  if (!e) return null;
  if (Date.now() - e.t > ENRICH_TTL_MS) {
    enrichCache.delete(url);
    return null;
  }
  return e.v;
}
function cachePut(url, v) {
  enrichCache.set(url, { t: Date.now(), v });
}

// ──────────────────────────────────────────────────────────────
/** Health */
// ──────────────────────────────────────────────────────────────
app.get("/health", (_req, res) => res.json({ ok: true }));

// ──────────────────────────────────────────────────────────────
/** Basic WP passthroughs kept for parity */
// ──────────────────────────────────────────────────────────────
app.get("/api/wp/posts", async (req, res) => {
  try {
    if (!WP) throw new Error("WP_BASE_URL not set");
    const page = Number(req.query.page || 1);
    const per_page = Math.max(1, Math.min(50, Number(req.query.per_page || 10)));
    const raw = await fetchJSON(
      `${WP}/wp-json/wp/v2/posts?page=${page}&per_page=${per_page}&_embed=1`
    );
    const posts = raw.map((p) => ({
      id: p.id,
      title: p.title?.rendered ?? "",
      slug: p.slug,
      date: p.date,
      excerpt: p.excerpt?.rendered ?? "",
      url: p.link,
    }));
    res.json(posts);
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

/**
 * Legacy events passthrough (try plugin route, then core v2 fallback).
 * NOTE: Your normalized /api/events below is what the app uses.
 */
app.get("/api/wp/events", async (_req, res) => {
  try {
    if (!WP) throw new Error("WP_BASE_URL not set");
    try {
      const raw = await fetchJSON(`${WP}/wp-json/example/v1/events`);
      return res.json(raw);
    } catch {
      const raw = await fetchJSON(
        `${WP}/wp-json/wp/v2/event?per_page=100&_embed=1&_fields=id,slug,link,title.rendered,date,acf,meta`
      );
      return res.json(raw);
    }
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

// ──────────────────────────────────────────────────────────────
// Music relevance scoring (title/category/tags only)
// ──────────────────────────────────────────────────────────────
const NEG = [
  "show","exhibition","fair","conference","summit","expo","workshop",
  "race","cup","open","championship","marathon","soapbox","motorcycle",
  "model","modelling","engineering","knitting","stitching","gardeners","question time"
];
const STRONG = [
  "music","concert","gig","festival","tour","orchestra","choir","symphony",
  "philharmonic","band","dj","edm","hip hop","hip-hop","rap","r&b","live","jazz","classical","opera"
];
const ACT_HINTS = [
  "the maccabees","suede","the national","bjork","madness","vans warped tour",
  "camden light orchestra","i’ll be your mirror","ill be your mirror","heavy metal"
];

function scoreMusic(row) {
  const title = String(row?.title || row?.name || "").toLowerCase();
  const cats = Array.isArray(row?.categories) ? row.categories.join(" ").toLowerCase()
            : String(row?.category || "").toLowerCase();
  const tags = Array.isArray(row?.tags) ? row.tags.join(" ").toLowerCase() : "";
  const hay = `${title} ${cats} ${tags}`;

  let s = 0;
  for (const n of NEG) if (hay.includes(n)) s -= 3;
  for (const k of STRONG) if (hay.includes(k)) s += (k === "live" ? 1 : 3);
  for (const h of ACT_HINTS) if (title.includes(h)) s += 4;
  const properWord = /^(?:the\s+)?[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3}$/.test(row?.title ?? "");
  if (properWord) s += 2;
  return s;
}
const isMusicScoreEnough = (s) => s >= 3;

// ──────────────────────────────────────────────────────────────
// Strict grounding context fed to the LLM
// ──────────────────────────────────────────────────────────────
function buildEventsContext(q, rows) {
  const top = rows.slice(0, 8);
  if (!top.length) return "";
  const lines = top.map((e) => {
    const bits = [];
    const title = e.title || e.name || `#${e.id}`;
    bits.push(title);
    bits.push(`date: ${e.date ? dateShort(e.date) : "Not specified"}`);
    bits.push(`venue: ${e.venue ? e.venue : "Not specified"}`);
    bits.push(`id: ${e.id}`);
    return `- ${e.category ? `[${e.category}] ` : ""}${bits.join(" · ")}`;
  });
  return `CONTEXT (authoritative events for "${q || "general"}"):
${lines.join("\n")}

RULES YOU MUST FOLLOW:
- Only refer to events listed in CONTEXT above. Do not mention anything else.
- If no listed event matches the request, you MUST output a section titled "Closest matches (from site)" listing up to 3 items from CONTEXT.
- For each listed item, provide: Title — Date — Venue. If a detail is missing, write "Not specified".
- Never invent events, dates, or venues.`;
}

// ──────────────────────────────────────────────────────────────
// Ensure rows carry URL/date/venue before enrichment
// ──────────────────────────────────────────────────────────────
async function augmentWithUrls(rows) {
  const out = [];
  for (const r of rows) {
    if (r && r.url && r.date && r.venue) { out.push(r); continue; }
    try {
      const full = await getEventById(r.id);
      if (full) {
        out.push({
          ...r,
          url: r.url ?? full.url,
          date: r.date ?? full.date,
          venue: r.venue ?? full.venue,
        });
      } else {
        out.push(r);
      }
    } catch {
      out.push(r);
    }
  }
  return out;
}

// ──────────────────────────────────────────────────────────────
// Enrich by scraping JSON-LD (incl. @graph) + HTML fallbacks
// ──────────────────────────────────────────────────────────────
async function enrichEvents(rows) {
  const out = [];
  function clean(v) {
    if (v == null) return "Not specified";
    let x = String(v).replace(/[{}]/g, "").replace(/\s+/g, " ").trim();
    return x || "Not specified";
  }
  function fallbackFromHtml(html) {
    let date, venue;
    const m1 = html.match(/<time[^>]+datetime=["']([^"']+)["']/i);
    if (m1) date = m1[1];
    if (!date) {
      const m2 = html.match(/itemprop=["']startDate["'][^>]*\bcontent=["']([^"']+)["']/i);
      if (m2) date = m2[1];
    }
    if (!date) {
      const m3 = html.match(/>\s*Date\s*:\s*([^<\n\r]+)/i);
      if (m3) date = m3[1].trim();
    }
    const locName =
      html.match(/itemprop=["']location["'][^>]*>\s*<[^>]*itemprop=["']name["'][^>]*>\s*([^<]+)/i)?.[1] ||
      html.match(/itemprop=["']location["'][^>]*\bcontent=["']([^"']+)["']/i)?.[1];
    if (locName) venue = locName.trim();
    if (!venue) {
      const m4 = html.match(/>\s*Venue\s*:\s*([^<\n\r]+)/i);
      if (m4) venue = m4[1].trim();
    }
    return { date, venue };
  }

  for (const e of rows) {
    const ev = { ...e };
    if (!ev.url || (ev.date && ev.venue)) { out.push(ev); continue; }

    // cache first
    const cached = cacheGet(ev.url);
    if (cached) {
      ev.date = ev.date || (cached.date || null);
      ev.venue = ev.venue || (cached.venue || "Not specified");
      ev.venue = clean(ev.venue);
      ev.date = ev.date ? String(ev.date) : null;
      out.push(ev);
      continue;
    }

    try {
      const r = await fetch(ev.url, { redirect: "follow" });
      if (r.ok) {
        const html = await r.text();
        const scripts = [...html.matchAll(/<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi)]
          .map(m => m[1]).filter(Boolean);

        let filled = false;

        for (const raw of scripts) {
          let data;
          try {
            const cleaned = raw.replace(/^\uFEFF/, "").trim();
            data = JSON.parse(cleaned);
          } catch { continue; }

          const nodes = [];
          const pushNode = (n) => { if (n && typeof n === "object") nodes.push(n); };
          if (Array.isArray(data)) data.forEach(pushNode);
          else {
            pushNode(data);
            if (data["@graph"] && Array.isArray(data["@graph"])) data["@graph"].forEach(pushNode);
          }

          for (const node of nodes) {
            const type = node["@type"];
            const types = Array.isArray(type) ? type : [type];
            const isEvent = types?.some(t => String(t).toLowerCase() === "event") ||
                            ("startDate" in node) || ("location" in node);
            if (!isEvent) continue;

            const start = node.startDate || node.start_time || node.start || null;

            let venueName = "";
            const loc = node.location;
            if (Array.isArray(loc)) {
              const first = loc.find(x => x && typeof x === "object" && (x.name || x.address));
              if (first) venueName = first.name || first.address?.name || first.address?.streetAddress || first.address?.addressLocality || "";
            } else if (loc && typeof loc === "object") {
              venueName = loc.name || loc.address?.name || loc.address?.streetAddress || loc.address?.addressLocality || "";
            } else if (typeof loc === "string") {
              venueName = loc;
            }

            if (start && !ev.date) ev.date = String(start);
            if (venueName && !ev.venue) ev.venue = venueName;
            if (ev.date && ev.venue) { filled = true; break; }
          }
          if (filled) break;
        }

        if (!filled) {
          const fb = fallbackFromHtml(html);
          if (!ev.date && fb.date) ev.date = fb.date;
          if (!ev.venue && fb.venue) ev.venue = fb.venue;
        }
      }
    } catch {}

    ev.date = ev.date ? String(ev.date) : null;
    ev.venue = clean(ev.venue);

    // store normalized in cache for next time
    cachePut(ev.url, { date: ev.date, venue: ev.venue });

    out.push(ev);
  }
  return out;
}

// ──────────────────────────────────────────────────────────────
// Lightweight builtin classifier + helpers (used by gatherHits)
// ──────────────────────────────────────────────────────────────
function builtinClassifyQuery(message) {
  const txt = String(message || "").toLowerCase();
  const cats = ["music","comedy","family","sport","sports","dance","exhibition"];
  const foundCats = cats.filter(c => txt.includes(c));

  const quoted = Array.from(txt.matchAll(/"([^"]+)"/g)).map(m => m[1]);
  const junk = ["what's on","whats on","what is on","show me","events","event","about"];
  let q = quoted.length
    ? quoted.join(" ")
    : foundCats.length
      ? foundCats.join(" ")
      : junk.reduce((s, j) => s.replace(j, ""), txt).trim();

  const parts = [];
  if (foundCats.length) parts.push(foundCats.join(", "));
  if (quoted.length) parts.push(`“${quoted.join(" ” “")}”`);
  return { q, parts, foundCats };
}

function builtinBuildAnswer({ parts, total, shown }) {
  const facet = parts?.length ? ` ${parts.join(" ")}` : "";
  if (total === 0) return { answer: `I couldn’t find any events${facet ? " for" + facet : ""}.`, hits: [] };
  return {
    answer: `I found ${total} event${total === 1 ? "" : "s"}${facet ? " for " + facet : ""}. Showing up to ${shown.length}.`,
    hits: shown,
  };
}

// ──────────────────────────────────────────────────────────────
/** LLM streaming hook (Ollama via ./lib/llm.js) */
// ──────────────────────────────────────────────────────────────
let streamChatFn = null;
try {
  const llmMod = await import("./lib/llm.js");
  if (llmMod && typeof llmMod.streamChat === "function") {
    streamChatFn = llmMod.streamChat;
  }
} catch { /* optional */ }

// ──────────────────────────────────────────────────────────────
// Hit gathering with adaptive routing (works when q=music returns [])
// ──────────────────────────────────────────────────────────────
async function gatherHits(message, limit) {
  const { q, foundCats } = builtinClassifyQuery(message);
  const txt = message.toLowerCase();

  const isMusicQuery =
    foundCats?.includes("music") ||
    /\bmusic|concert|gig|band|dj|edm|orchestra|choir|symphony|jazz|classical|opera|hip[ -]?hop|rap|r&b\b/.test(txt);

  const pool = await findEvents({ limit: 200, q: "" });

  const quoted = Array.from(txt.matchAll(/"([^"]+)"/g)).map((m) => m[1]?.toLowerCase()).filter(Boolean);
  let candidates = pool;
  if (quoted.length) {
    candidates = pool.filter((r) => quoted.some((qz) => String(r.title || "").toLowerCase().includes(qz)));
  }

  if (isMusicQuery) {
    const scored = candidates
      .map((r) => ({ ...r, _score: scoreMusic(r) }))
      .sort((a, b) => b._score - a._score);

    const strong = scored.filter((r) => isMusicScoreEnough(r._score));
    if (strong.length) {
      return { q: q || "music", rows: strong, shown: strong.slice(0, limit), isExact: true };
    }
    return { q: q || "music", rows: scored, shown: scored.slice(0, limit), isExact: false };
  }

  const rows = q ? await findEvents({ limit: 100, q }) : pool;
  return { q, rows, shown: rows.slice(0, limit), isExact: true };
}

// ──────────────────────────────────────────────────────────────
// Deterministic builders (used by SSE + JSON)
// ──────────────────────────────────────────────────────────────
function buildClosestMatchesAnswer(message, shown) {
  const top = shown.slice(0, 3);
  const header = `Couldn't find direct matches for “${message}”. Closest matches (from site):`;
  const lines = top.map((e, i) => {
    const title = e.title || e.name || `#${e.id}`;
    const date = dateShort(e.date) || "Not specified";
    const venue = e.venue || "Not specified";
    return `${i + 1}. ${title} — ${date} — ${venue}`;
  });
  return [header, "", ...lines].join("\n");
}

function buildFoundListAnswer(shown) {
  const lines = shown.map((e, i) => {
    const title = e.title || e.name || `#${e.id}`;
    const date = dateShort(e.date) || "Not specified";
    const venue = e.venue || "Not specified";
    return `${i + 1}. ${title} — ${date} — ${venue}`;
  });
  return `Here ${shown.length === 1 ? "is" : "are"} ${shown.length} event${shown.length === 1 ? "" : "s"} found:\n\n${lines.join("\n")}`;
}

// ──────────────────────────────────────────────────────────────
/** SSE Chat (POST and GET) */
// ──────────────────────────────────────────────────────────────
async function handleSSEChat(message, limit, res) {
  const { q, rows, shown, isExact } = await gatherHits(message, limit);

  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache, no-transform");
  res.setHeader("Connection", "keep-alive");
  if (typeof res.flushHeaders === "function") res.flushHeaders();

  res.write("event: hello\n");
  res.write('data: {"ok":true}\n\n');

  // Ensure URLs and enrich before emitting
  const withUrls = await augmentWithUrls(shown);
  const enrichedShown = await enrichEvents(withUrls);

  if (enrichedShown.length) {
    res.write(`data: ${JSON.stringify({ type: "hits", hits: enrichedShown })}\n\n`);
  }

  // NEW BEHAVIOR:
  // - Strong/exact: deterministic summary (no LLM streaming)
  // - Fuzzy: stream via LLM if available; otherwise deterministic "closest matches"
  if (isExact) {
    const text = enrichedShown.length
      ? buildFoundListAnswer(enrichedShown)
      : `I couldn’t find any events${q ? ` for ${q}` : ""}.`;
    res.write(`data: ${JSON.stringify({ token: text, type: "text", delta: text })}\n\n`);
    res.write("event: done\n");
    res.write(`data: ${JSON.stringify({ text })}\n\n`);
    res.end();
    return;
  }

  // Fuzzy path: stream if we can
  if (streamChatFn) {
    const baseSystem = process.env.LLM_SYSTEM_PROMPT || "You are a concise assistant.";
    const ctx = buildEventsContext(q, enrichedShown);
    const system = ctx ? `${baseSystem}\n\n${ctx}` : baseSystem;

    await streamChatFn({
      userText: message,
      system,
      onToken: (t) => res.write(`data: ${JSON.stringify({ token: t, type: "text", delta: t })}\n\n`),
      onDone: (final) => {
        res.write("event: done\n");
        res.write(`data: ${JSON.stringify({ text: final })}\n\n`);
        res.end();
      },
      onError: (err) => {
        res.write("event: error\n");
        res.write(`data: ${JSON.stringify({ error: String(err) })}\n\n`);
        res.end();
      },
    });
    return;
  }

  // Fuzzy but no LLM available → deterministic “closest matches”
  const text = enrichedShown.length
    ? buildClosestMatchesAnswer(message, enrichedShown)
    : `I couldn’t find any events${q ? ` for ${q}` : ""}.`;
  res.write(`data: ${JSON.stringify({ token: text, type: "text", delta: text })}\n\n`);
  res.write("event: done\n");
  res.write(`data: ${JSON.stringify({ text })}\n\n`);
  res.end();
}

app.post("/ai/chat", async (req, res) => {
  try {
    const message = String(req.body?.message || "").trim();
    if (!message) return res.status(400).json({ error: "message required" });
    const limit = Math.max(1, Math.min(20, Number(req.body?.limit || 10)));
    await handleSSEChat(message, limit, res);
  } catch (e) {
    if (!res.headersSent) res.status(500).json({ error: String(e) });
    else try { res.end(); } catch {}
  }
});

app.get("/ai/chat", async (req, res) => {
  try {
    const message = String(req.query?.message || "").trim();
    if (!message) return res.status(400).json({ error: "message required" });
    const limit = Math.max(1, Math.min(20, Number(req.query?.limit || 10)));
    await handleSSEChat(message, limit, res);
  } catch (e) {
    if (!res.headersSent) res.status(500).json({ error: String(e) });
    else try { res.end(); } catch {}
  }
});

// ──────────────────────────────────────────────────────────────
/** AI (JSON) — /ai/ask
 * Uses the SAME adaptive path as /ai/chat:
 * gatherHits → augmentWithUrls → enrichEvents → deterministic answer
 */
// ──────────────────────────────────────────────────────────────
app.post("/ai/ask", async (req, res) => {
  try {
    const message = String(req.body?.message || "").trim();
    if (!message) return res.status(400).json({ error: "message required" });
    const limit = Math.max(1, Math.min(20, Number(req.body?.limit || 10)));

    const { q, rows, shown, isExact } = await gatherHits(message, limit);
    const withUrls = await augmentWithUrls(shown);
    const enrichedShown = await enrichEvents(withUrls);

    let answer;
    if (enrichedShown.length === 0) {
      answer = `I couldn’t find any events${q ? ` for ${q}` : ""}.`;
    } else if (!isExact) {
      answer = buildClosestMatchesAnswer(message, enrichedShown);
    } else {
      answer = buildFoundListAnswer(enrichedShown);
    }

    res.json({
      ok: true,
      q,
      isExact,
      total: rows.length,
      hits: enrichedShown,
      answer,
    });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

// ──────────────────────────────────────────────────────────────
/** Normalized Events API (used by UI and AI)
 * Now supports:
 *   - ?fuzzy=1  -> use adaptive scoring (e.g., for q=music)
 *   - ?enrich=1 -> augment each result with URL/date/venue (scraped if needed)
 * Backward compatible: by default returns the same array as before.
 */

app.get("/api/events", async (req, res) => {
  try {
    const limit = Math.max(1, Math.min(100, Number(req.query.limit || 50)));
    const q = String(req.query.q || "");
    const fuzzy = ["1","true","yes"].includes(String(req.query.fuzzy || "").toLowerCase());
    const doEnrich = ["1","true","yes"].includes(String(req.query.enrich || "").toLowerCase());

    let rows;
    if (fuzzy) {
      const { shown } = await gatherHits(q, limit);
      rows = shown;
    } else {
      rows = await findEvents({ limit, q });
    }

    if (doEnrich) {
      rows = await enrichEvents(await augmentWithUrls(rows));
    }

    res.json(rows.slice(0, limit));
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

app.get("/api/events/:id", async (req, res) => {
  try {
    const id = String(req.params.id || "").trim();
    if (!id) return res.status(400).json({ error: "missing id" });

    const core = await getEventById(id);
    const base = {
      id: String((core && core.id) ?? id),
      title: (core && core.title) || "",
      date: (core && core.date) || null,
      venue: (core && core.venue) || "",
      url: (core && core.url) || (WP ? `${WP.replace(/\/$/, "")}/?p=${id}` : "")
    };

    const doEnrich = ["1","true","yes"].includes(String(req.query.enrich || "").toLowerCase());
    const clean = (v) => (v || "").toString().replace(/[{}]+/g, "").replace(/\s+/g, " ").trim();

    if (!doEnrich) {
      return res.json({
        id: base.id,
        title: base.title,
        date: base.date || null,
        venue: clean(base.venue),
        url: base.url
      });
    }

    const withUrls = await augmentWithUrls([base]);
    const enriched = await enrichEvents(withUrls);
    const one = (enriched && enriched[0]) || base;

    return res.json({
      id: String(one.id || base.id),
      title: one.title || base.title,
      date: one.date || null,
      venue: clean(one.venue || base.venue),
      url: one.url || base.url
    });
  } catch (err) {
    res.status(500).json({ error: String((err && err.message) || err) });
  }
}););

// ──────────────────────────────────────────────────────────────
/** Admin + Webhooks */
// ──────────────────────────────────────────────────────────────
app.get("/admin/ping", (_req, res) => {
  invalidateEventsCache();
  io.emit("event-updated", { source: "admin-ping", ts: Date.now() });
  res.json({ ok: true, emitted: "event-updated" });
});

app.post("/webhooks/wp", (req, res) => {
  if (!verifyWebhook(req)) {
    return res.status(401).json({ ok: false, error: "unauthorized" });
  }
  const { id, action = "updated" } = req.body || {};
  const key = `${id}:${action}`;
  if (shouldDrop(key)) {
    console.log("[webhook] dropped duplicate within 2s:", key);
    return res.json({ ok: true, dropped: true });
  }
  console.log("[webhook] received:", req.body);
  invalidateEventsCache();
  io.emit("event-updated", { source: "wp-webhook", payload: req.body, ts: Date.now() });
  res.json({ ok: true, received: req.body });
});

// ──────────────────────────────────────────────────────────────
httpServer.listen(PORT, HOST, () => {
  console.log(`HTTP+Socket server on http://localhost:${PORT}`);
  console.log(`Socket.IO path: /socket.io  CORS origin: ${CORS_ORIGIN}`);
  console.log(`WP base: ${WP}`);
});
